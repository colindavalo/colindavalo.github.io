<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>High-Performance Poisson Voronoi</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f5f5f5; font-family: sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 260px;
            color: #333;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            pointer-events: auto;
            z-index: 10;
        }
        .control-group { margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between; }
        .control-group label { font-weight: bold; font-size: 13px; }
        .control-group input { width: 70px; padding: 4px; border: 1px solid #ccc; border-radius: 4px; }
        
        button {
            background-color: #4682B4; color: white; border: none; width: 100%;
            padding: 8px; border-radius: 4px; cursor: pointer; font-size: 13px; margin-top: 5px;
        }
        button:hover { background-color: #3a6d99; }
        
        button.secondary { background-color: #2E8B57; margin-top: 5px;}
        button.secondary:hover { background-color: #256f45; }

        #loading { display: none; font-size: 0.8em; color: #666; text-align: center; margin-top:8px; font-weight: bold;}
        .stats { font-size: 0.75em; color: #888; text-align: center; margin-top: 5px;}
    </style>
</head>
<body>

<div id="info">
    <h3>Ideal Selberg Poisson Voronoi diagrams in SL(3,R)</h3>
    <p style="font-size:0.85em; color:#555;"> A Poisson distribution in the space of horofunction conditionned to having a fixed horofunctionis partially sampled. Then we draw the intersectio of the associated tesselation with a cone in the projective model of the symmetric space, corresponding to a parallel set. The fixed horofunction is centered at the tip of this cone.</p>

<p style="font-size:0.85em; color:#555;"> The domain bounded by the green sides is the cell of the horofunction centerd at the tip of the cone, for the finite set of horofunctions sampled.</p>
    
    <div class="control-group">
        <label for="nInput">Size N of the box in the Cartan algebra in which the horofunctions are sampled:</label>
        <input type="number" id="nInput" value="200" min="1" max="2000" step="100">
    </div>

    <div class="control-group">
        <label for="precInput">Precision (allows to remove faces that are too small, high precision means more computation):</label>
        <input type="number" id="precInput" value="100" min="1" step="100">
    </div>

    <button id="btnResample">Generate (Resample)</button>
    
    <hr style="border: 0; border-top: 1px solid #eee; margin: 10px 0;">
    
    <button class="secondary" id="btnSaveImage">Save Image (PNG)</button>
    <button class="secondary" id="btnSaveHTML">Save 3D Scene (HTML)</button>

    <div id="loading">Calculating... (This may take time)</div>
    <div class="stats" id="statsOutput">Faces: 0</div>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- 1. Scene Setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf5f5f5);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 100);
    camera.position.set(1.8, 1.5, 2.5);

    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    // --- 2. Visual Environment ---
    
    const coneGeom = new THREE.ConeGeometry(0.5, 0.5, 64, 1, true);
    coneGeom.rotateX(Math.PI); 
    coneGeom.translate(0, 0.25, 0);
    const coneMat = new THREE.MeshPhongMaterial({
        color: 0xaaaaaa, transparent: true, opacity: 0.05, 
        side: THREE.DoubleSide, depthWrite: false 
    });
    scene.add(new THREE.Mesh(coneGeom, coneMat));

    // --- 3. Math & Matrix Logic ---

    function getRandomOrthogonal() {
        const v1 = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
        let v2 = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5);
        v2.sub(v1.clone().multiplyScalar(v1.dot(v2))).normalize();
        const v3 = new THREE.Vector3().crossVectors(v1, v2).normalize();
        return [v1, v2, v3];
    }

    function getTraceCoeffsFromEigen(lam1, lam2, lam3, basis) {
        const u = basis[0], v = basis[1], w = basis[2];
        
        const a11 = lam1*u.x*u.x + lam2*v.x*v.x + lam3*w.x*w.x;
        const a22 = lam1*u.y*u.y + lam2*v.y*v.y + lam3*w.y*w.y;
        const a33 = lam1*u.z*u.z + lam2*v.z*v.z + lam3*w.z*w.z;
        const a12 = lam1*u.x*u.y + lam2*v.x*v.y + lam3*w.x*w.y;

        return new THREE.Vector4(
            a11 - a22,              
            a11 + a22 - 2 * a33,    
            2 * a12,                
            a33                     
        );
    }

    // --- 4. Visibility Check (Optimization) ---
    
    function checkFaceVisibility(cA, cB, allCoeffs, idxA, idxB, samplesCount) {
        const N = new THREE.Vector3().subVectors(cA, cB);
        const D = cA.w - cB.w;
        const lenSq = N.lengthSq();
        if (lenSq < 1e-9) return false;
        const len = Math.sqrt(lenSq);
        const normal = N.clone().divideScalar(len);
        
        const coneCenter = new THREE.Vector3(0, 0.25, 0);
        const distToCenter = normal.dot(coneCenter) + (D / len);
        const P_center = coneCenter.clone().sub(normal.clone().multiplyScalar(distToCenter));
        
        if (P_center.length() > 1.5) return false;

        let arbitrary = new THREE.Vector3(0, 1, 0);
        if (Math.abs(normal.y) > 0.9) arbitrary.set(1, 0, 0);
        const U = new THREE.Vector3().crossVectors(normal, arbitrary).normalize();
        const V = new THREE.Vector3().crossVectors(normal, U).normalize();

        let visibleSamples = 0;
        const SAMPLE_RADIUS = 0.6; 
        const pTest = new THREE.Vector3();

        for(let k=0; k<samplesCount; k++) {
            const r = Math.sqrt(Math.random()) * SAMPLE_RADIUS;
            const theta = Math.random() * 2 * Math.PI;
            pTest.copy(P_center)
                 .addScaledVector(U, r * Math.cos(theta))
                 .addScaledVector(V, r * Math.sin(theta));

            if (pTest.y < 0.0 || pTest.y > 0.5) continue;
            if (pTest.x*pTest.x + pTest.z*pTest.z > pTest.y*pTest.y) continue;

            const valRef = pTest.dot(cA) + cA.w;
            let occluded = false;
            
            for(let m=0; m<allCoeffs.length; m++) {
                if (m === idxA || m === idxB) continue;
                const cK = allCoeffs[m];
                if (pTest.dot(cK) + cK.w < valRef - 0.001) {
                    occluded = true; break;
                }
            }
            if (!occluded) return true; 
        }
        return false; 
    }

    // --- 5. Core Logic ---

    let allCoeffs = [];
    let wallMeshes = [];
    const visGroup = new THREE.Group();
    scene.add(visGroup);

    function generateData(nValue) {
        allCoeffs = [];
        // A0 = Diag(1, 1, 0)
        allCoeffs.push(new THREE.Vector4(0, 2, 0, 0));

        const Range = 10.0;
        for (let i = 0; i < nValue; i++) {
            const x = Math.random() * Range;
            const y = Math.random() * Range;
            const O = getRandomOrthogonal();
            allCoeffs.push(getTraceCoeffsFromEigen(x, y, 0, O));
        }
    }

    function buildVoronoi(precisionSamples) {
        wallMeshes.forEach(m => {
            m.geometry.dispose();
            m.material.dispose();
            visGroup.remove(m);
        });
        wallMeshes = [];

        const count = allCoeffs.length;

        // Data Texture Setup (supports high N)
        const dataArray = new Float32Array(count * 4);
        for(let i=0; i<count; i++) {
            dataArray[i*4+0] = allCoeffs[i].x;
            dataArray[i*4+1] = allCoeffs[i].y;
            dataArray[i*4+2] = allCoeffs[i].z;
            dataArray[i*4+3] = allCoeffs[i].w;
        }
        
        const dataTexture = new THREE.DataTexture(dataArray, count, 1, THREE.RGBAFormat, THREE.FloatType);
        dataTexture.minFilter = THREE.NearestFilter;
        dataTexture.magFilter = THREE.NearestFilter;
        dataTexture.needsUpdate = true;

        const vertexShader = `
            varying vec3 vPos;
            varying vec3 vNormal;
            void main() {
                vPos = (modelMatrix * vec4(position, 1.0)).xyz;
                vNormal = normalize(normalMatrix * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            uniform sampler2D uDataTexture;
            uniform int uTotal;
            uniform int uIdxA;
            uniform int uIdxB;
            uniform vec3 uColor;

            varying vec3 vPos;
            varying vec3 vNormal;

            vec4 getCoeff(int index) {
                float u = (float(index) + 0.5) / float(uTotal);
                return texture2D(uDataTexture, vec2(u, 0.5));
            }

            void main() {
                // Geometric Margins
                float capMargin = min(vPos.y, 0.5 - vPos.y);
                float r = length(vec2(vPos.x, vPos.z));
                float surfMargin = vPos.y - r;
                float geoMargin = min(capMargin, surfMargin);
                
                if (geoMargin < 0.0) discard;

                // Voronoi Margins
                vec4 cA = getCoeff(uIdxA);
                float valRef = dot(vPos, cA.xyz) + cA.w;
                
                float voronoiMargin = 100.0; 

                for (int k = 0; k < 2001; k++) { 
                    if (k >= uTotal) break;
                    if (k == uIdxA || k == uIdxB) continue;
                    
                    vec4 cK = getCoeff(k);
                    float valK = dot(vPos, cK.xyz) + cK.w;
                    
                    float diff = valK - valRef;
                    if (diff < -0.0001) discard; 

                    if (diff < voronoiMargin) voronoiMargin = diff;
                }

                // Rendering
                float minMargin = min(geoMargin, voronoiMargin);
                float fw = fwidth(minMargin);
                float lineFactor = 1.0 - smoothstep(0.0, 1.5 * fw, minMargin);

                vec3 light = normalize(vec3(0.5, 1.0, 0.8));
                float d = max(dot(vNormal, light), 0.0)*0.4 + 0.6;
                
                vec3 baseCol = uColor * d;
                vec3 edgeCol = vec3(0.0, 0.0, 0.0); 

                gl_FragColor = vec4(mix(baseCol, edgeCol, lineFactor), 1.0);
            }
        `;

        const colNormal = new THREE.Color(0x4682B4);
        const colBase   = new THREE.Color(0x2E8B57);

        let facesDrawn = 0;

        for (let i = 0; i < count; i++) {
            for (let j = i + 1; j < count; j++) {
                
                const cA = allCoeffs[i];
                const cB = allCoeffs[j];

                // --- OPTIMIZATION CHECK ---
                // Identify if this is a "Green Face" (involves A0 at index 0)
                const isGreenFace = (i === 0 || j === 0);

                // Logic: If it's NOT green, run the visibility check.
                // If it IS green, skip check and draw it anyway.
                if (!isGreenFace) {
                    if (!checkFaceVisibility(cA, cB, allCoeffs, i, j, precisionSamples)) {
                        continue;
                    }
                }
                
                facesDrawn++;

                const faceColor = isGreenFace ? colBase : colNormal;

                const nVec = new THREE.Vector3().subVectors(cA, cB);
                const dVal = cA.w - cB.w;
                const len = nVec.length();
                
                const planeSize = 2.0;
                const geom = new THREE.PlaneGeometry(planeSize, planeSize);
                const visualNormal = nVec.clone();
                geom.lookAt(visualNormal);
                const dist = -dVal / len;
                geom.translate(
                    (visualNormal.x / len) * dist,
                    (visualNormal.y / len) * dist,
                    (visualNormal.z / len) * dist
                );

                const mat = new THREE.ShaderMaterial({
                    uniforms: {
                        uDataTexture: { value: dataTexture },
                        uTotal: { value: count },
                        uIdxA: { value: i },
                        uIdxB: { value: j },
                        uColor: { value: faceColor }
                    },
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    side: THREE.DoubleSide
                });

                const mesh = new THREE.Mesh(geom, mat);
                visGroup.add(mesh);
                wallMeshes.push(mesh);
            }
        }
        return facesDrawn;
    }

    // --- 6. Save Functions ---

    function saveAsImage() {
        renderer.render(scene, camera);
        const link = document.createElement('a');
        link.download = 'voronoi_cone.png';
        link.href = renderer.domElement.toDataURL('image/png');
        link.click();
    }

    function saveAsHTML() {
        const dataJson = JSON.stringify(allCoeffs);
        const camPos = camera.position.toArray();
        const camTarget = controls.target.toArray();

        const exportContent = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Saved Poisson Voronoi Scene</title>
    <style>body{margin:0;overflow:hidden;background:#f5f5f5;}</style>
</head>
<body>
<script type="importmap">
  { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
<\/script>
<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const rawCoeffs = ${dataJson};
    const allCoeffs = rawCoeffs.map(c => new THREE.Vector4(c.x, c.y, c.z, c.w));
    const count = allCoeffs.length;

    const scene = new THREE.Scene(); scene.background = new THREE.Color(0xf5f5f5);
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.01, 100);
    camera.position.fromArray(${JSON.stringify(camPos)});
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.fromArray(${JSON.stringify(camTarget)}); controls.update();

    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dl = new THREE.DirectionalLight(0xffffff, 0.5); dl.position.set(10,20,10); scene.add(dl);

    const coneGeom = new THREE.ConeGeometry(0.5, 0.5, 64, 1, true);
    coneGeom.rotateX(Math.PI); coneGeom.translate(0, 0.25, 0);
    scene.add(new THREE.Mesh(coneGeom, new THREE.MeshPhongMaterial({color:0xaaaaaa, transparent:true, opacity:0.05, side:THREE.DoubleSide, depthWrite:false})));

    const dataArray = new Float32Array(count * 4);
    for(let i=0; i<count; i++) {
        dataArray[i*4] = allCoeffs[i].x; dataArray[i*4+1] = allCoeffs[i].y;
        dataArray[i*4+2] = allCoeffs[i].z; dataArray[i*4+3] = allCoeffs[i].w;
    }
    const dataTexture = new THREE.DataTexture(dataArray, count, 1, THREE.RGBAFormat, THREE.FloatType);
    dataTexture.minFilter = THREE.NearestFilter; dataTexture.magFilter = THREE.NearestFilter; dataTexture.needsUpdate = true;

    const vs = \`varying vec3 vPos; varying vec3 vNormal;
        void main() { vPos = (modelMatrix * vec4(position, 1.0)).xyz; vNormal = normalize(normalMatrix * normal);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }\`;
    const fs = \`uniform sampler2D uDataTexture; uniform int uTotal; uniform int uIdxA; uniform int uIdxB; uniform vec3 uColor;
        varying vec3 vPos; varying vec3 vNormal;
        vec4 getCoeff(int index) { float u = (float(index)+0.5)/float(uTotal); return texture2D(uDataTexture, vec2(u,0.5)); }
        void main() {
            float capM = min(vPos.y, 0.5-vPos.y); float r = length(vec2(vPos.x, vPos.z)); float surfM = vPos.y-r;
            float geoMargin = min(capM, surfM);
            if(geoMargin < 0.0) discard;
            vec4 cA = getCoeff(uIdxA); float valRef = dot(vPos, cA.xyz)+cA.w;
            float vorMargin = 100.0;
            for(int k=0; k<2001; k++) {
                if(k>=uTotal) break; if(k==uIdxA || k==uIdxB) continue;
                vec4 cK = getCoeff(k); float diff = (dot(vPos, cK.xyz)+cK.w) - valRef;
                if(diff < -0.0001) discard;
                if(diff < vorMargin) vorMargin = diff;
            }
            float minMargin = min(geoMargin, vorMargin); float fw = fwidth(minMargin);
            float lf = 1.0 - smoothstep(0.0, 1.5*fw, minMargin);
            vec3 light = normalize(vec3(0.5,1.0,0.8)); float d = max(dot(vNormal,light),0.0)*0.4+0.6;
            gl_FragColor = vec4(mix(uColor*d, vec3(0.0), lf), 1.0);
        }\`;
    
    const colNormal = new THREE.Color(0x4682B4); const colBase = new THREE.Color(0x2E8B57);

    function checkVis(cA, cB, idxA, idxB) {
        const N = new THREE.Vector3().subVectors(cA, cB); const D = cA.w - cB.w;
        if (N.lengthSq() < 1e-9) return false;
        const len = N.length(); const n = N.clone().divideScalar(len);
        const coneC = new THREE.Vector3(0, 0.25, 0);
        const P = coneC.clone().sub(n.clone().multiplyScalar(n.dot(coneC) + D/len));
        if(P.length()>1.5) return false;
        let arb = new THREE.Vector3(0,1,0); if(Math.abs(n.y)>0.9) arb.set(1,0,0);
        const U = new THREE.Vector3().crossVectors(n, arb).normalize();
        const V = new THREE.Vector3().crossVectors(n, U).normalize();
        const pTest = new THREE.Vector3();
        for(let k=0; k<40; k++) { 
            const r = Math.sqrt(Math.random())*0.6; const th = Math.random()*6.28;
            pTest.copy(P).addScaledVector(U, r*Math.cos(th)).addScaledVector(V, r*Math.sin(th));
            if(pTest.y<0.0 || pTest.y>0.5 || pTest.x*pTest.x+pTest.z*pTest.z > pTest.y*pTest.y) continue;
            let occ = false;
            for(let m=0; m<count; m++) {
                if(m==idxA||m==idxB) continue;
                if(pTest.dot(allCoeffs[m])+allCoeffs[m].w < pTest.dot(cA)+cA.w - 0.001) { occ=true; break;}
            }
            if(!occ) return true;
        }
        return false;
    }

    for(let i=0; i<count; i++) {
        for(let j=i+1; j<count; j++) {
            const isGreen = (i==0 || j==0);
            if(!isGreen) {
                if(!checkVis(allCoeffs[i], allCoeffs[j], i, j)) continue;
            }
            const cA = allCoeffs[i]; const cB = allCoeffs[j];
            const nVec = new THREE.Vector3().subVectors(cA, cB);
            const geom = new THREE.PlaneGeometry(2,2);
            const vN = nVec.clone(); geom.lookAt(vN);
            geom.translate((vN.x/nVec.length()) * -(cA.w-cB.w)/nVec.length(), (vN.y/nVec.length()) * -(cA.w-cB.w)/nVec.length(), (vN.z/nVec.length()) * -(cA.w-cB.w)/nVec.length());
            const col = isGreen ? colBase : colNormal;
            const mat = new THREE.ShaderMaterial({
                uniforms: { uDataTexture:{value:dataTexture}, uTotal:{value:count}, uIdxA:{value:i}, uIdxB:{value:j}, uColor:{value:col} },
                vertexShader: vs, fragmentShader: fs, side: THREE.DoubleSide
            });
            scene.add(new THREE.Mesh(geom, mat));
        }
    }
    function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    animate();
<\/script></body></html>`;

        const blob = new Blob([exportContent], {type: 'text/html'});
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'poisson_voronoi_scene.html';
        link.click();
    }

    function update() {
        const nInput = document.getElementById('nInput');
        const precInput = document.getElementById('precInput');
        const loadDiv = document.getElementById('loading');
        const statsDiv = document.getElementById('statsOutput');
        
        let nVal = parseInt(nInput.value);
        let pVal = parseInt(precInput.value);
        if (isNaN(nVal) || nVal < 3) nVal = 3;
        if (isNaN(pVal) || pVal < 10) pVal = 50;

        loadDiv.style.display = 'block';
        statsDiv.innerText = 'Generating data...';

        setTimeout(() => {
            const start = performance.now();
            generateData(nVal);
            statsDiv.innerText = 'Calculating Geometry...';
            
            setTimeout(() => {
                const faces = buildVoronoi(pVal);
                const end = performance.now();
                loadDiv.style.display = 'none';
                statsDiv.innerText = `Faces: ${faces} | Time: ${((end-start)/1000).toFixed(2)}s`;
            }, 20);
        }, 20);
    }

    document.getElementById('btnResample').addEventListener('click', update);
    document.getElementById('btnSaveImage').addEventListener('click', saveAsImage);
    document.getElementById('btnSaveHTML').addEventListener('click', saveAsHTML);
    document.getElementById('nInput').addEventListener('keypress', (e) => { if(e.key === 'Enter') update(); });
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    update();

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

</script>
</body>
</html>