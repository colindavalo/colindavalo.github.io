<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Poisson Voronoi - A0 Modified</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f5f5f5; font-family: sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 280px;
            color: #333;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            pointer-events: auto;
        }
        .control-group { margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between; }
        .control-group label { font-weight: bold; font-size: 14px; }
        .control-group input { width: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 4px; }
        
        .stats { font-size: 0.8em; color: #555; margin-top: 10px; background: #eee; padding: 5px; border-radius: 4px; text-align: center;}
        
        button {
            background-color: #4682B4; color: white; border: none; width: 100%;
            padding: 10px; border-radius: 4px; cursor: pointer; font-size: 14px; margin-top: 10px;
        }
        button:hover { background-color: #3a6d99; }
        #loading { display: none; font-size: 0.8em; color: #888; text-align: center; margin-top:5px; }
    </style>
</head>
<body>

<div id="info">
    <h3>Poisson Voronoi</h3>
    <p style="font-size:0.9em; margin-bottom:10px">
        <span style="color: #4682B4; font-weight:bold;">Blue:</span> Standard Faces<br>
        <span style="color: #2E8B57; font-weight:bold;">Green:</span> Faces with A<sub>0</sub>
    </p>
    
    <div class="control-group">
        <label for="nInput">N (Matrices):</label>
        <input type="number" id="nInput" value="40" min="3" step="1">
    </div>

    <div class="control-group">
        <label for="precInput" title="Monte Carlo samples">Precision:</label>
        <input type="number" id="precInput" value="100" min="10" step="10">
    </div>

    <button id="btnResample">Generate / Resample</button>
    <div id="loading">Calculating...</div>

    <div class="stats" id="statsOutput">Faces: 0 / 0</div>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- 1. Scene Setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf5f5f5);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 100);
    camera.position.set(1.8, 1.5, 2.5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    // --- 2. Math Helpers ---

    function getRandomOrthogonal() {
        const v1 = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
        let v2 = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5);
        v2.sub(v1.clone().multiplyScalar(v1.dot(v2))).normalize();
        const v3 = new THREE.Vector3().crossVectors(v1, v2).normalize();
        return [v1, v2, v3];
    }

    function getTraceCoeffsFromEigen(lam1, lam2, lam3, basis) {
        const u = basis[0], v = basis[1], w = basis[2];
        
        const a11 = lam1*u.x*u.x + lam2*v.x*v.x + lam3*w.x*w.x;
        const a22 = lam1*u.y*u.y + lam2*v.y*v.y + lam3*w.y*w.y;
        const a33 = lam1*u.z*u.z + lam2*v.z*v.z + lam3*w.z*w.z;
        const a12 = lam1*u.x*u.y + lam2*v.x*v.y + lam3*w.x*w.y;

        return new THREE.Vector4(
            a11 - a22,              
            a11 + a22 - 2 * a33,    
            2 * a12,                
            a33                     
        );
    }

    // --- 3. Visual Context ---
    
    const coneGeom = new THREE.ConeGeometry(0.5, 0.5, 64, 1, true);
    coneGeom.rotateX(Math.PI); 
    coneGeom.translate(0, 0.25, 0);
    const coneMat = new THREE.MeshPhongMaterial({
        color: 0x888888, transparent: true, opacity: 0.1, 
        side: THREE.DoubleSide, depthWrite: false 
    });
    scene.add(new THREE.Mesh(coneGeom, coneMat));

    const ringGeo = new THREE.RingGeometry(0.49, 0.51, 64);
    ringGeo.rotateX(-Math.PI / 2);
    ringGeo.translate(0, 0.5, 0);
    scene.add(new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({ color: 0x333333 })));
    
    scene.add(new THREE.AxesHelper(0.2));
    scene.add(new THREE.GridHelper(2, 20, 0xdddddd, 0xffffff));

    // --- 4. Logic ---

    function checkFaceVisibility(cA, cB, allCoeffs, idxA, idxB, samplesCount) {
        const N = new THREE.Vector3().subVectors(cA, cB);
        const D = cA.w - cB.w;
        const lenSq = N.lengthSq();
        if (lenSq < 1e-9) return false;
        const len = Math.sqrt(lenSq);
        const normal = N.clone().divideScalar(len);
        
        const coneCenter = new THREE.Vector3(0, 0.25, 0);
        const distToCenter = normal.dot(coneCenter) + (D / len);
        const P_center = coneCenter.clone().sub(normal.clone().multiplyScalar(distToCenter));
        
        if (P_center.length() > 1.5) return false;

        let arbitrary = new THREE.Vector3(0, 1, 0);
        if (Math.abs(normal.y) > 0.9) arbitrary.set(1, 0, 0);
        const U = new THREE.Vector3().crossVectors(normal, arbitrary).normalize();
        const V = new THREE.Vector3().crossVectors(normal, U).normalize();

        let visibleSamples = 0;
        const SAMPLE_RADIUS = 0.6; 
        const pTest = new THREE.Vector3();

        for(let k=0; k<samplesCount; k++) {
            const r = Math.sqrt(Math.random()) * SAMPLE_RADIUS;
            const theta = Math.random() * 2 * Math.PI;
            pTest.copy(P_center)
                 .addScaledVector(U, r * Math.cos(theta))
                 .addScaledVector(V, r * Math.sin(theta));

            if (pTest.y < 0.0 || pTest.y > 0.5) continue;
            if (pTest.x*pTest.x + pTest.z*pTest.z > pTest.y*pTest.y) continue;

            const valRef = pTest.dot(cA) + cA.w;
            let occluded = false;
            for(let m=0; m<allCoeffs.length; m++) {
                if (m === idxA || m === idxB) continue;
                const cK = allCoeffs[m];
                if (pTest.dot(cK) + cK.w < valRef - 0.001) {
                    occluded = true; break;
                }
            }
            if (!occluded) return true; 
        }
        return false; 
    }

    let allCoeffs = [];
    let wallMeshes = [];
    const visGroup = new THREE.Group();
    scene.add(visGroup);

    const MAX_MATRICES = 128; 

    function generateData(nValue) {
        allCoeffs = [];
        
        // --- A0 (Base) is index 0 ---
        // A0 = Diag(1, 1, 0)
        // Tr(X*A0) = 1*(z+x) + 1*(z-x) + 0 = 2z
        // Coeffs in visual space (x, z_math, y_math) => (0, 2, 0)
        allCoeffs.push(new THREE.Vector4(0, 2, 0, 0));

        const Range = 10.0;
        for (let i = 0; i < nValue; i++) {
            const x = Math.random() * Range;
            const y = Math.random() * Range;
            const O = getRandomOrthogonal();
            allCoeffs.push(getTraceCoeffsFromEigen(x, y, 0, O));
        }
    }

    function buildVoronoi(precisionSamples) {
        // Cleanup
        wallMeshes.forEach(m => {
            m.geometry.dispose();
            m.material.dispose();
            visGroup.remove(m);
        });
        wallMeshes = [];

        const count = allCoeffs.length;
        const effectiveMax = Math.min(count, MAX_MATRICES);
        const uniformCoeffs = new Float32Array(MAX_MATRICES * 4);
        
        for(let i=0; i<effectiveMax; i++) {
            uniformCoeffs[i*4] = allCoeffs[i].x;
            uniformCoeffs[i*4+1] = allCoeffs[i].y;
            uniformCoeffs[i*4+2] = allCoeffs[i].z;
            uniformCoeffs[i*4+3] = allCoeffs[i].w;
        }

        const vertexShader = `
            varying vec3 vPos;
            varying vec3 vNormal;
            void main() {
                vPos = (modelMatrix * vec4(position, 1.0)).xyz;
                vNormal = normalize(normalMatrix * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            uniform vec4 allCoeffs[${MAX_MATRICES}];
            uniform int uTotal;
            uniform int uIdxA;
            uniform int uIdxB;
            uniform vec3 uColor;

            varying vec3 vPos;
            varying vec3 vNormal;

            void main() {
                // --- 1. Margin Checks for Edge Drawing ---

                // A. Cone Geometric Margins
                float capMargin = min(vPos.y, 0.5 - vPos.y);
                float r = length(vec2(vPos.x, vPos.z));
                float surfMargin = vPos.y - r;
                float geoMargin = min(capMargin, surfMargin);
                
                if (geoMargin < 0.0) discard;

                // B. Voronoi Margins
                vec4 cA = allCoeffs[uIdxA];
                float valRef = dot(vPos, cA.xyz) + cA.w;
                
                float voronoiMargin = 100.0; 

                for (int k = 0; k < ${MAX_MATRICES}; k++) {
                    if (k >= uTotal) break;
                    if (k == uIdxA || k == uIdxB) continue;
                    
                    vec4 cK = allCoeffs[k];
                    float valK = dot(vPos, cK.xyz) + cK.w;
                    
                    float diff = valK - valRef;
                    if (diff < -0.0001) discard; // Occluded

                    if (diff < voronoiMargin) voronoiMargin = diff;
                }

                // --- 2. Rendering ---
                float minMargin = min(geoMargin, voronoiMargin);
                float fw = fwidth(minMargin);
                float lineFactor = 1.0 - smoothstep(0.0, 1.5 * fw, minMargin);

                vec3 light = normalize(vec3(0.5, 1.0, 0.8));
                float d = max(dot(vNormal, light), 0.0)*0.4 + 0.6;
                
                vec3 baseCol = uColor * d;
                vec3 edgeCol = vec3(0.0, 0.0, 0.0); 

                gl_FragColor = vec4(mix(baseCol, edgeCol, lineFactor), 1.0);
            }
        `;

        let facesDrawn = 0;
        const potentialFaces = (count * (count - 1)) / 2;

        // Colors
        const colNormal = new THREE.Color(0x4682B4); // SteelBlue
        const colBase   = new THREE.Color(0x2E8B57); // SeaGreen

        for (let i = 0; i < count; i++) {
            for (let j = i + 1; j < count; j++) {
                
                const cA = allCoeffs[i];
                const cB = allCoeffs[j];

                if (!checkFaceVisibility(cA, cB, allCoeffs, i, j, precisionSamples)) {
                    continue;
                }

                facesDrawn++;

                // Index 0 is A0. Use Green if A0 is involved.
                let faceColor = (i === 0 || j === 0) ? colBase : colNormal;

                // Geometry
                const nVec = new THREE.Vector3().subVectors(cA, cB);
                const dVal = cA.w - cB.w;
                const len = nVec.length();
                
                const planeSize = 2.0;
                const geom = new THREE.PlaneGeometry(planeSize, planeSize);
                
                const visualNormal = nVec.clone();
                geom.lookAt(visualNormal);
                const dist = -dVal / len;
                geom.translate(
                    (visualNormal.x / len) * dist,
                    (visualNormal.y / len) * dist,
                    (visualNormal.z / len) * dist
                );

                const mat = new THREE.ShaderMaterial({
                    uniforms: {
                        allCoeffs: { value: uniformCoeffs },
                        uTotal: { value: effectiveMax },
                        uIdxA: { value: i },
                        uIdxB: { value: j },
                        uColor: { value: faceColor }
                    },
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    side: THREE.DoubleSide
                });

                const mesh = new THREE.Mesh(geom, mat);
                visGroup.add(mesh);
                wallMeshes.push(mesh);
            }
        }

        document.getElementById('statsOutput').innerText = 
            `Faces Drawn: ${facesDrawn} / ${potentialFaces} pairs`;
    }

    function update() {
        const nInput = document.getElementById('nInput');
        const precInput = document.getElementById('precInput');
        const loadDiv = document.getElementById('loading');
        
        let nVal = parseInt(nInput.value);
        let pVal = parseInt(precInput.value);
        if (isNaN(nVal) || nVal < 2) nVal = 3;
        if (isNaN(pVal) || pVal < 1) pVal = 50;

        loadDiv.style.display = 'block';
        setTimeout(() => {
            generateData(nVal);
            buildVoronoi(pVal);
            loadDiv.style.display = 'none';
        }, 20);
    }

    document.getElementById('btnResample').addEventListener('click', update);
    document.getElementById('nInput').addEventListener('keypress', (e) => { if(e.key === 'Enter') update(); });
    document.getElementById('precInput').addEventListener('keypress', (e) => { if(e.key === 'Enter') update(); });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    update();

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

</script>
</body>
</html>